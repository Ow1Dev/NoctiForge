use proto::api::action::{
    InvokeRequest, InvokeResult,
    function_runner_service_server::{FunctionRunnerService, FunctionRunnerServiceServer},
};
use serde::{Serialize, de::DeserializeOwned};
use std::{future::Future, marker::PhantomData};
use tokio::net::UnixListener;
use tonic::Response;

pub use tonic::Status;

pub async fn start<F, Fut, In, Out>(handler: F) -> Result<(), Box<dyn std::error::Error>>
where
    F: Send + Sync + Clone + 'static + Fn(In) -> Fut,
    Fut: Future<Output = Result<Out, Status>> + Send + Sync + 'static,
    In: DeserializeOwned + Send + Sync + 'static,
    Out: Serialize + Send + Sync + 'static,
{
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .init();

    struct MyService<F, Fut, In, Out>
    where
        F: Send + Sync + Clone + 'static + Fn(In) -> Fut,
        Fut: Future<Output = Result<Out, Status>> + Send + 'static,
        In: DeserializeOwned + Send + 'static,
        Out: Serialize + Send + Sync + 'static,
    {
        handler: F,
        _marker: PhantomData<(Fut, In, Out)>,
    }

    // Implement the service trait (generated by Tonic)
    #[tonic::async_trait]
    impl<F, Fut, In, Out> FunctionRunnerService for MyService<F, Fut, In, Out>
    where
        F: Send + Sync + Clone + 'static + Fn(In) -> Fut,
        Fut: Future<Output = Result<Out, Status>> + Send + 'static + std::marker::Sync,
        In: DeserializeOwned + Send + 'static + std::marker::Sync,
        Out: Serialize + Send + Sync + 'static,
    {
        async fn invoke(
            &self,
            request: tonic::Request<InvokeRequest>,
        ) -> Result<Response<InvokeResult>, Status> {
            // check for type
            let result = if std::any::TypeId::of::<In>() == std::any::TypeId::of::<()>() {
                let unit: In = unsafe { std::mem::zeroed() };
                (self.handler.clone())(unit).await?
            } else {
                let input: In = serde_json::from_str(&request.into_inner().payload.unwrap())
                    .map_err(|e| Status::invalid_argument(e.to_string()))?;
                (self.handler.clone())(input).await?
            };

            let json =
                serde_json::to_string(&result).map_err(|e| Status::internal(e.to_string()))?;

            Ok(Response::new(InvokeResult { output: json }))
        }
    }

    let socket_path = std::env::var("SOCKET_PATH").expect("'SOCKET_PATH' was not set");

    if std::path::Path::new(&socket_path).exists() {
        std::fs::remove_file(&socket_path)?;
    }

    let listener = UnixListener::bind(&socket_path)?;
    log::info!("Starting server on Unix socket: {}", socket_path);

    let svc = FunctionRunnerServiceServer::new(MyService {
        handler,
        _marker: PhantomData,
    });

    tonic::transport::Server::builder()
        .add_service(svc)
        .serve_with_incoming(tokio_stream::wrappers::UnixListenerStream::new(listener))
        .await?;

    Ok(())
}
