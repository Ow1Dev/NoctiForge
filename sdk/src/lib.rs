use proto::api::{InvokeResult, InvokeRequest};
use tonic::{Response};
use serde::Serialize;
use std::{future::Future, net::SocketAddr};

pub use tonic::Status;

pub async fn start<F, Fut, T>(handler: F) -> Result<(), Box<dyn std::error::Error>>
where
    F: Send + Sync + Clone + 'static + Fn() -> Fut,
    Fut: Future<Output = Result<T, Status>> + Send + 'static,
    T: Serialize + Send + Sync + 'static,
{
    env_logger::Builder::from_default_env()
        .filter_level(log::LevelFilter::Info)
        .init();

    struct MyService<F>
    where
        F: Send + Sync + Clone + 'static,
    {
        handler: F,
    }

    // Implement the service trait (generated by Tonic)
    #[tonic::async_trait]
    impl<F, Fut, T> proto::api::function_runner_service_server::FunctionRunnerService for MyService<F>
    where
        F: Send + Sync + Clone + 'static + Fn() -> Fut,
        Fut: Future<Output = Result<T, Status>> + Send + 'static,
        T: Serialize + Send + Sync + 'static,
    {
        async fn invoke(
            &self,
            _request: tonic::Request<InvokeRequest>,
        ) -> Result<Response<InvokeResult>, tonic::Status> {
            let result = (self.handler)().await?;
            let json = serde_json::to_string(&result).map_err(|e| Status::internal(e.to_string()))?;
            Ok(Response::new(proto::api::InvokeResult {
                output: json,
            }))
        }
    }

    let addr: SocketAddr = "[::1]:54036".parse()?;
    log::info!("Starting server on {}", addr);

    let svc = proto::api::function_runner_service_server::FunctionRunnerServiceServer::new(MyService { handler });

    tonic::transport::Server::builder()
        .add_service(svc)
        .serve(addr)
        .await?;

    Ok(())
}

